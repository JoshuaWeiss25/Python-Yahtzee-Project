# Reflection
## Design Process:
We started by going through what games we would want to make. [Partner B] and [Partner A] started by mentioning some things that seemed (to me) quite out of the scope of our abilities. I suggested that we make something simpler. Eventually, Yahtzee came up. We thought it would be quite easy at first, but there were *many* unexpected challenges.

Before the first time our group met to work on the project, I started to try and map out how we might do things. what was their own function, what was a class, etc. I made the dice class, which would remain largely unchanged. I realized that we needed some kind of file I/O and tried to find where we might be able to use it. I eventually landed on using files to store the player's score, and after further research, determined that I could use a pickle file (.pkl) to store the scores, with a dictionary for each player. The dictionary allowed me to also store a Boolean to determine if a row had been played. I then also started to draft the methods that would calculate scores. The first time we met we got a lot done. We were assigning jobs and helping each other where we could. By the end of that meeting, we had made a todo list of things that had to be finished, and at that point the main structure of our project was almost fully fleshed out. All four code files existed at that point. We needed to add comments & explanations, refine user input, and account for errors and bad inputs, as well as finishing the score calculations. From that point until after Thanksgiving break, we all put in work in nearly everything. The UI changed multiple times, and we each tested the game *trying* to break it. We met again on the Monday after break where we fixed the last errors.

## Challenges
A lot of these challenges were solved by me throwing random changes at a wall to see what worked, and several times I thought it shouldn't work but somehow does and I never figured out why; but I decided "if it ain't broke, don't fix it"
### Rows
Each row needed its own function to calculate the score. 3 of the rows proved particularly challenging: The Full House, Small Straight, and Large Straight. The night before the first meeting I was able to figure out a way to do the Full House. I then actually realized I needed to account for certain edge cases - but when I tried them it behaved as it should've. At the time I didn't understand *why* it worked but decided not to rock the boat. I eventually understood it. However, I couldn't figure out the Small and Large Straights. In our last meeting, a *slightly* better way to do the FH was suggested, but I chose not to change it since it worked and we were running out of time.   
At the first meeting I realized that once sorted, there are only 3 combinations for Large Straights and can brute force check for them, which I did. The Small Straight was still confusing. That night, I looked into various options, and determined that if I sort and remove duplicates I can do another brute-force-check. However, I didn't know a good way to remove duplicates until a forum recommended casting the list into a set and back into a list. This worked, which still amazes me. I once again thought I would have edge cases but I tested and found out it works anyway. I still don't *fully* understand why the edge cases work but I have a basic idea and don't want to mess with it.
### Rolling 6s
The first full playthrough of the game ever (not in it's completed state) was me and my roommate playing a 2-player game. We played through almost the *entire* game when we realized not a single 6 was ever rolled. I checked my code and almost imediately realized why: I made a stupid mistake and the random number generator would only generate 1-5. This was literally just changing a 5 to a six and was an obvious problem so it wasn't really a challenge but it was funny so I thought I'd include it.
### Calculating Winner
There were two errors that I encountered and *I* never *fully* solved. The first one was eventually fixed by [Partner A]. At the end of the game, I had a block of code that would calculate the winner. This entailed finding the highest number in a list, so I naturally tried to use the *max()* function. However, It kept giving me an error related to something along the lines of *int*s not being callable. I tried everything I could think of, even copying the block of code into a different file (testing.py) where I manually constructed scorecards to run it - and it worked. It worked in the testing file, but not the main file. I eventually gave up and asked my groupmates to take a look. They both looked clueless. [Partner B] and I got to talking about something else when [Partner A], I suspect, had an idea that gave him a trail to follow. He eventually determined that the *max()* function wasnâ€™t working because we had a variable earlier in the code called *max*. He changed the variable to *maxx* and it worked. It made me feel quite stupid.
### Folders & Files
This was the other error that I couldn't solve. There are certain cases where the program would fail to properly create the scorecard files. If this happened, I couldn't (and still can't) think of a way to correct the error and continue the program. The only way I could solve it was to exit the program while giving as much explanation as I could. There are probably an infinite number of things that can cause this, but I only ever ran into two:
1. Storage space. In edstem, the VM that runs the code has a limited capacity. If you tried to create too many files, it would error out (at about 735 scorecards, if I remember correctly). I theoretically could put a hard limit on player count but I liked that the game could theoretically handle up to the integer limit of players. If the code is run locally with a different IDE like VScode, the storage limit is much higher and isn't a problem. This could happen whenever a user requests to play with a large number of people, so I put warnings at large player counts to confirm that they really want to.  
2. Scorecards folder doesn't exist or is in the wrong location. This is mainly a problem when trying to "install" the program to a different place, such as a different edstem workspace or VScode. I couldn't figure out how to create a folder with python so if the program has no where to put the scorecard files it errors. Once the game is running properly, however, this isn't a problem unless the user manually deletes files
#### Deleting files
I wasn't able to figure out how to delete the used scorecards at the end of a game in time for submission, but the game will only make new cards if they don't already exist - meaning that the game will only use as much storage as needed for the highest player count the user has done. The game overwrites & resets the old, used cards that it needs at the beginning of every game and uses those.
### Reroll input
During play testing with my friends, one consistent point of confusion was inputting the dice to reroll. At first, the Dice class was made to work in the way that was easier to code; not what was easiest to use. Originally, the player had to input the index that corresponded to the die they wanted to keep. Despite the added complexity, however, we did offset the indices so they would be from 1-5. This was still confusing, though, because the dice weren't labeled and it wasn't intuitive to people who had played Yahtzee before. The original solution to fix this was to label the dice when printing, but we kept putting that off because we couldn't figure out a good way to display it. Eventually I gave in and changed the code to take the numbers on the "face" of the die the player wants to keep. This was much more complicated to code and had quite a few issues (one specific one that I still don't understand what was happening) but is more intuitive to the player, and closer to how the player thinks about the game.
### Exiting the game
Because Yahtzee is a fairly long game even in single player, when testing certain things I'd play the game up until the point I need to test, try it, and either that errors the game out, or it would continue working. I'd then exit the game by doing something I knew would cause an error. However, as I started patching the errors, I ran out of easy ways to exit the game early. I looked all over edstem and couldn't find a way to terminate the program (which my CS friend pointed out is a severe oversight). I even renamed files to try and get it to break (which in hindsight would never have worked because python is loaded into RAM). Eventually, I discovered that *sys.exit()* existed. I then went to (nearly) every place the game takes an input and added a bit that accepted an input of "Exit" and exited the game if it was entered. This meant I could test something and then easily exit the game so I could restart it to make a change.

## Lessons learned
I learned a lot from making this game. One of the biggest lessons I learned is that it's okay to ask your friends/partners for help. Sometimes all a problem needs is a fresh set of eyes or a brain that thinks differently. I also learned that it's okay not to always fully understand how something works - but that it can help quite a lot. Another **really** big thing I learned is that what's easiest to code isn't always the best for the user - and that you need to find a balance between how much effort you put in and how much effort the user would have to put in. I could've put in the effort to learn how to make a GUI instead of the text interface - but that would have taken a long time and wasn't within the scope of what we had to do.
